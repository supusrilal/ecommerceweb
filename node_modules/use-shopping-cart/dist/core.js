'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var toolkit = require('@reduxjs/toolkit');
var reduxPersist = require('redux-persist');
var uuid = require('uuid');
require('@stripe/stripe-js');

const isClient = typeof window === 'object';

const formatCurrencyString = ({
  value,
  currency,
  language = isClient ? navigator.language : 'en-US'
}) => {
  const numberFormat = new Intl.NumberFormat(language, {
    style: 'currency',
    currency,
    currencyDisplay: 'symbol'
  });
  const parts = numberFormat.formatToParts(value);
  let zeroDecimalCurrency = true;

  for (const part of parts) {
    if (part.type === 'decimal') {
      zeroDecimalCurrency = false;
      break
    }
  }

  value = zeroDecimalCurrency ? value : parseFloat((value / 100).toFixed(2));
  return numberFormat.format(value)
};

function updateFormattedTotalPrice(state) {
  state.formattedTotalPrice = formatCurrencyString({
    value: state.totalPrice,
    currency: state.currency,
    language: state.language
  });
}

function updateFormattedValue(state, id) {
  state.cartDetails[id].formattedValue = formatCurrencyString({
    value: state.cartDetails[id].value,
    currency: state.currency,
    language: state.language
  });
}

function updateFormattedPrice(state, id) {
  state.cartDetails[id].formattedPrice = formatCurrencyString({
    value: state.cartDetails[id].price,
    currency: state.currency,
    language: state.language
  });
}

function Entry({ id, product, quantity, price_metadata, product_metadata }) {
  return {
    ...product,
    id,
    quantity,
    value: product.price * quantity,
    price_data: {
      ...product.price_data,
      ...price_metadata
    },
    product_data: {
      ...product.product_data,
      ...product_metadata
    }
  }
}

function createEntry({
  state,
  id,
  product,
  count,
  price_metadata,
  product_metadata
}) {
  const entry = Entry({
    id,
    product,
    quantity: count,
    price_metadata,
    product_metadata
  });

  state.cartDetails[id] = entry;
  updateFormattedValue(state, id);
  updateFormattedPrice(state, id);

  state.totalPrice += entry.value;
  state.cartCount += count;
  updateFormattedTotalPrice(state);
}

function updateEntry({
  state,
  id,
  count,
  price_metadata,
  product_metadata
}) {
  const entry = state.cartDetails[id];
  if (entry.quantity + count <= 0) return removeEntry({ state, id })

  state.cartDetails[id] = Entry({
    id,
    state,
    product: entry,
    quantity: entry.quantity + count,
    price_metadata,
    product_metadata
  });
  updateFormattedValue(state, id);

  state.totalPrice += entry.price * count;
  state.cartCount += count;
  updateFormattedTotalPrice(state);
}

function removeEntry({ state, id }) {
  const cartDetails = state.cartDetails;
  state.totalPrice -= cartDetails[id].value;
  state.cartCount -= cartDetails[id].quantity;
  delete cartDetails[id];
  updateFormattedTotalPrice(state);
}

function updateQuantity({ state, id, quantity }) {
  const entry = state.cartDetails[id];
  updateEntry({
    state,
    id,
    count: quantity - entry.quantity
  });
}

const initialState = {
  cartMode: 'checkout-session',
  mode: 'payment',
  currency: 'USD',
  language: isClient ? navigator.language : 'en-US',
  lastClicked: '',
  shouldDisplayCart: false,
  cartCount: 0,
  totalPrice: 0,
  formattedTotalPrice: '',
  cartDetails: {},
  stripe: '',
  shouldPersist: true
};

const slice = toolkit.createSlice({
  name: 'cart',
  initialState,
  reducers: {
    addItem: {
      reducer(state, { payload: { product, options } }) {
        const { count, price_metadata, product_metadata } = options;

        const id =
          product.id ||
          product.price_id ||
          product.sku_id ||
          product.sku ||
          uuid.v4();

        if (id in state.cartDetails) {
          updateEntry({
            state,
            id,
            count,
            price_metadata,
            product_metadata
          });
        } else {
          createEntry({
            state,
            id,
            product,
            count,
            price_metadata,
            product_metadata
          });
        }
      },
      prepare(product, options = { count: 1 }) {
        if (!options.price_metadata) options.price_metadata = {};
        if (!options.product_metadata) options.product_metadata = {};
        if (!options.count) options.count = 1;
        return { payload: { product, options } }
      }
    },
    incrementItem: {
      reducer(state, { payload: { id, options } }) {
        updateEntry({
          state,
          id,
          count: options.count
        });
      },
      prepare(id, options = { count: 1 }) {
        return { payload: { id, options } }
      }
    },
    decrementItem: {
      reducer(state, { payload: { id, options } }) {
        if (state.cartDetails[id].quantity - options.count <= 0)
          return removeEntry({ state, id })

        updateEntry({
          state,
          id,
          count: -options.count
        });
      },
      prepare(id, options = { count: 1 }) {
        return { payload: { id, options } }
      }
    },
    clearCart: {
      reducer(state) {
        state.cartCount = 0;
        state.totalPrice = 0;
        state.cartDetails = {};
        updateFormattedTotalPrice(state);
      }
    },
    setItemQuantity: {
      reducer(state, { payload: { id, quantity } }) {
        if (quantity > 0 && id in state.cartDetails)
          return updateQuantity({ ...state, state, id, quantity })
        else if (quantity === 0) return removeEntry({ state, id })
      },
      prepare(id, quantity) {
        return { payload: { id, quantity } }
      }
    },
    removeItem: {
      reducer(state, { payload: { id } }) {
        removeEntry({ state, id });
      },
      prepare(id) {
        return { payload: { id } }
      }
    },
    loadCart: {
      reducer(state, { payload: { cartDetails, shouldMerge } }) {
        if (!shouldMerge) {
          state.cartCount = 0;
          state.totalPrice = 0;
          state.cartDetails = {};
        }

        for (const id in cartDetails) {
          const entry = cartDetails[id];
          createEntry({
            state,
            id: entry.id,
            product: entry,
            count: entry.quantity
          });
        }
      },
      prepare(cartDetails, shouldMerge = true) {
        return { payload: { cartDetails, shouldMerge } }
      }
    },
    handleCartHover(state) {
      state.shouldDisplayCart = true;
    },
    handleCartClick(state) {
      state.shouldDisplayCart = !state.shouldDisplayCart;
    },
    handleCloseCart(state) {
      state.shouldDisplayCart = false;
    },
    storeLastClicked(state, { payload }) {
      state.lastClicked = payload;
    },
    changeStripeKey(state, { payload }) {
      state.stripe = payload;
    },
    changeLanguage(state, { payload }) {
      state.language = payload;
    },
    changeCurrency(state, { payload }) {
      state.currency = payload;
    }
  }
});

slice.actions.redirectToCheckout = (sessionId) => ({
  type: 'cart/redirectToCheckout',
  payload: { sessionId }
});
slice.actions.checkoutSingleItem = (itemsOrPriceId) => {
  const quantity = itemsOrPriceId.quantity || 1;

  const cartItems = (() => {
    if (typeof itemsOrPriceId === 'string') {
      return {
        lineItems: [
          {
            price: itemsOrPriceId,
            quantity
          }
        ]
      }
    }
    if (Object.prototype.hasOwnProperty.call(itemsOrPriceId, 'price')) {
      return {
        lineItems: [
          {
            price: itemsOrPriceId.price,
            quantity
          }
        ]
      }
    }
    /**
     * Backward compatibility (SKU)
     */
    if (Object.prototype.hasOwnProperty.call(itemsOrPriceId, 'sku')) {
      return {
        items: [
          {
            sku: itemsOrPriceId.sku,
            quantity
          }
        ]
      }
    }
    return []
  })();

  return {
    type: 'cart/checkoutSingleItem',
    payload: {
      cartItems
    }
  }
};

const { reducer, actions } = slice;

/**
 * Returns the constructor name of any value.
 * @param {any} value
 * @returns string
 */
function typeOf(value) {
  if (value === undefined) return 'undefined'
  if (value === null) return 'null'
  return value.constructor.name
}

class PropertyValueError extends Error {
  constructor({ property, method, expected, received }) {
    const plural = Array.isArray(expected);
    const expectedString = plural
      ? `are ${expected.map((v) => JSON.stringify(v)).join(', ')}`
      : `is ${JSON.stringify(expected)}`;
    const methodString = typeof method === 'string' ? ` in ${method}()` : '';
    super(
      `Invalid value ${JSON.stringify(
        received
      )} was received for ${property}. Valid ${
        plural ? 'values' : 'value'
      } for ${property}${methodString} ${expectedString}.`
    );
    this.name = 'PropertyValueError';
  }
}

class PropertyTypeError extends TypeError {
  constructor({ property, expected, received }) {
    const plural = Array.isArray(expected);
    const expectedString = plural
      ? `are ${expected.map((v) => JSON.stringify(v)).join(', ')}`
      : `is ${JSON.stringify(expected)}`;
    super(
      `Invalid value with type ${JSON.stringify(
        received
      )} was received for ${property}. Valid ${
        plural ? 'types' : 'type'
      } for ${property} ${expectedString}.`
    );
    this.name = 'PropertyTypeError';
  }
}

class PropertyRangeError extends RangeError {
  constructor({ property, between, below, above, received }) {
    let expectedString;
    if (Array.isArray(between))
      expectedString = `between ${between[0]} and ${between[1]}`;
    else if (['string', 'number'].includes(typeof below))
      expectedString = `below ${below}`;
    else if (['string', 'number'].includes(typeof above))
      expectedString = `above ${above}`;

    super(
      `Invalid value ${JSON.stringify(
        received
      )} was received for ${property}. Valid range for ${property} is ${expectedString}.`
    );
    this.name = 'PropertyRangeError';
  }
}

function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
function getCheckoutData(cart) {
  const lineItems = [];
  for (const sku in cart.cartDetails)
    lineItems.push({ price: sku, quantity: cart.cartDetails[sku].quantity });

  const options = {
    mode: cart.mode,
    lineItems,
    successUrl: cart.successUrl,
    cancelUrl: cart.cancelUrl,
    billingAddressCollection: cart.billingAddressCollection
      ? 'required'
      : 'auto',
    submitType: 'auto'
  };

  if (_optionalChain([cart, 'access', _ => _.allowedCountries, 'optionalAccess', _2 => _2.length])) {
    options.shippingAddressCollection = {
      allowedCountries: cart.allowedCountries
    };
  }

  return options
}

const handleStripe = (store) => (next) => async (action) => {
  const stripePublicKey = store.getState().stripe;
  const cart = store.getState();

  const checkout = ['cart/redirectToCheckout', 'cart/checkoutSingleItem'];
  if (checkout.includes(action.type)) {
    if (typeof stripePublicKey !== 'string') {
      throw new PropertyTypeError({
        property: 'stripe',
        expected: 'string',
        received: typeOf(stripePublicKey)
      })
    } else if (stripePublicKey.length === 0) {
      throw new PropertyRangeError({
        property: 'stripe.length',
        above: 0,
        received: stripePublicKey.length
      })
    }
  }

  if (action.type === 'cart/redirectToCheckout') {
    const stripe = initializeStripe(stripePublicKey);
    if (cart.cartMode === 'checkout-session') {
      return stripe.redirectToCheckout({
        sessionId: action.payload.sessionId
      })
    } else if (cart.cartMode === 'client-only') {
      const checkoutData = getCheckoutData(cart);
      return stripe.redirectToCheckout(checkoutData)
    } else {
      throw new PropertyValueError({
        property: 'cartMode',
        method: 'redirectToCheckout',
        expected: ['client-only', 'checkout-session'],
        received: cart.cartMode
      })
    }
  } else if (action.type === 'cart/checkoutSingleItem') {
    const stripe = initializeStripe(stripePublicKey);

    if (cart.cartMode === 'client-only') {
      const options = {
        mode: cart.mode,
        successUrl: cart.successUrl,
        cancelUrl: cart.cancelUrl,
        ...action.payload.cartItems
      };
      return stripe.redirectToCheckout(options)
    } else {
      throw new PropertyValueError({
        property: 'cartMode',
        method: 'checkoutSingleItem',
        expected: 'client-only',
        received: cart.cartMode
      })
    }
  }

  return next(action)
};

function initializeStripe(publicKey) {
  try {
    // eslint-disable-next-line no-undef
    const stripe = Stripe(publicKey);
    stripe.registerAppInfo({
      name: 'use-shopping-cart',
      version: "3.1.4",
      url: 'https://useshoppingcart.com',
      // eslint-disable-next-line camelcase
      partner_id: 'pp_partner_H8MLmI3e9Oc3IK'
    });
    return stripe
  } catch (error) {
    console.error('Unable to initialize Stripe.');
    throw error
  }
}

const handleWarnings = (store) => (next) => async (action) => {
  const count = ['cart/addItem', 'cart/incrementItem', 'cart/decrementItem'];
  if (
    count.includes(action.type) &&
    typeof action.payload.options.count !== 'number'
  ) {
    console.warn(
      `Invalid count used with action ${
        action.type
      }: count must be a number. The current type is ${typeOf(
        action.payload.options.count
      )}.`,
      action
    );
    return
  }

  const quantity = ['cart/setItemQuantity'];
  if (quantity.includes(action.type)) {
    if (typeof action.payload.quantity !== 'number') {
      console.warn(
        `Invalid quantity used with action ${
          action.type
        }: quantity must be a number. The current type is ${typeOf(
          action.payload.quantity
        )}.`,
        action
      );
      return
    } else if (action.payload.quantity < 0) {
      console.warn(
        `Invalid quantity used with action ${
          action.type
        }: quantity must be greater than zero. The current value is ${JSON.stringify(
          action.payload.quantity
        )}.`,
        action
      );
      return
    }
  }

  const id = ['cart/incrementItem', 'cart/decrementItem', 'cart/removeItem'];
  if (
    id.includes(action.type) &&
    !(action.payload.id in store.getState().cartDetails)
  ) {
    console.warn(
      `Invalid product ID used with action ${
        action.type
      }: the ID must already be in the cart. The current value is ${JSON.stringify(
        action.payload.id
      )}.`,
      action
    );
    return
  }

  return next(action)
};

function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }
async function filterCart(cartDetails, filter) {
  const filteredCart = {};

  for (const sku in cartDetails) {
    const entry = cartDetails[sku];
    if (await filter(entry)) filteredCart[sku] = entry;
  }

  return filteredCart
}

function noop() {}
function createNoopStorage() {
  return {
    getItem: noop,
    setItem: noop,
    removeItem: noop
  }
}

function createLocalStorage() {
  return {
    async getItem(key) {
      return window.localStorage.getItem(key)
    },
    async setItem(key, value) {
      return window.localStorage.setItem(key, value)
    },
    async removeItem(key) {
      return window.localStorage.removeItem(key)
    }
  }
}

function createShoppingCartStore(options) {
  options.shouldPersist = _nullishCoalesce(options.shouldPersist, () => ( true));

  if (!isClient) {
    return toolkit.configureStore({
      reducer,
      preloadedState: { ...initialState, ...options }
    })
  }
  let storage;
  if (isClient) storage = options.storage || createLocalStorage();
  else storage = createNoopStorage();
  delete options.storage;

  const persistConfig = {
    key: _nullishCoalesce(options.persistKey, () => ( 'root')),
    version: 1,
    storage,
    whitelist: ['cartCount', 'totalPrice', 'formattedTotalPrice', 'cartDetails']
  };
  const persistedReducer = reduxPersist.persistReducer(persistConfig, reducer);

  const newInitialState = { ...initialState, ...options };
  updateFormattedTotalPrice(newInitialState);

  return toolkit.configureStore({
    reducer: options.shouldPersist ? persistedReducer : reducer,
    preloadedState: newInitialState,
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        serializableCheck: {
          ignoredActions: options.shouldPersist
            ? [reduxPersist.FLUSH, reduxPersist.REHYDRATE, reduxPersist.PAUSE, reduxPersist.PERSIST, reduxPersist.PURGE, reduxPersist.REGISTER]
            : ['persist/PERSIST']
        }
      }).concat(handleStripe, handleWarnings)
  })
}

Object.defineProperty(exports, 'createPersistedStore', {
  enumerable: true,
  get: function () { return reduxPersist.persistStore; }
});
exports.actions = actions;
exports.createShoppingCartStore = createShoppingCartStore;
exports.filterCart = filterCart;
exports.formatCurrencyString = formatCurrencyString;
exports.reducer = reducer;
//# sourceMappingURL=core.js.map
